# Issue 13: `Or1<T>` Missing Natural `From<T>` and `Into<T>` Conversions

## Summary

`Or1<T>` is a sum type with a single variant. It is therefore isomorphic to `T` itself.
However, there is no `From<T> for Or1<T>` or `From<Or1<T>> for T` implementation,
making `Or1` essentially unusable as a natural wrapper. Users must write `Or1::T0(value)`
to wrap and `.t0().unwrap()` to unwrap.

## Location

**File:** `src/lib.rs`

The `or1` module is generated by the `or!` macro with `$count = 1`. The general-purpose
`From<Tk>` impls from Issue 3 would handle `From<T0> for Or1<T0>`, but the reverse
direction (`From<Or1<T>> for T`) is specific to `Or1`.

## Why It Is a Problem

### `Or1` is isomorphic to `T`

A sum type with exactly one variant is just a newtype wrapper. It serves no purpose as a
"choice between types" — it wraps a single type unconditionally. The natural conversions
should be:

```rust
let x: Or1<u8> = 42u8.into();   // Or1::T0(42)
let y: u8 = x.into();            // 42
```

Without these conversions, `Or1` is awkward to use in the rare cases where it does arise
(e.g. in generic code that works for any `OrN`).

### Consistency with `Or0`

`Or0` is an uninhabited type (no variants). It is isomorphic to `!` (the never type).
`Or1<T>` is the single-variant case. These two edge cases should be handled coherently:

- `Or0` should implement `From<!>` (if/when never type is stabilized)
- `Or1<T>` should implement bidirectional `From<T>` / `From<Or1<T>>`

### Makes generic code work correctly

Generic code parameterized over `OrN` types should work naturally at both ends of the
spectrum (`Or1` through `Or8` etc.). Without `From<T>` for `Or1<T>`, any generic utility
that relies on `From` bounds (see Issue 3) silently fails for `Or1`.

## Proposed Fix

### `From<T> for Or1<T>` (covered by Issue 3)

If the general `From<Tk>` fix from Issue 3 is applied, `From<T0>` for `Or1<T0>` is
automatically covered.

### `From<Or1<T>> for T`

This conversion is unique to `Or1`. Add it specifically in the `or1` module or in a
dedicated `@singleton` macro arm:

```rust
// In or1 module:
impl<T0> From<Or<T0>> for T0 {
    #[inline]
    fn from(or: Or<T0>) -> T0 {
        match or {
            Or::T0(item) => item,
        }
    }
}
```

This can be added in the existing `or0` / `or1` module sections, or emitted by a
special case in the macro when `$count == 1`.

### `into_inner()` is already available

`Or1<T>` already provides `.into_inner()` (from the `impl<T> Or<T>` block where all
types are the same — which is always the case for `Or1`). However, `From<Or1<T>> for T`
is the idiomatic conversion mechanism and enables `or1_value.into()` in typed contexts.

## Investigation Steps for the Implementing Agent

1. Confirm that the `From<Tk>` fix (Issue 3) covers `From<T0> for Or1<T0>`.
2. Add the specific `From<Or1<T0>> for T0` impl in `src/lib.rs`. This can be:
   a. Added to the `or0` module section (after `or0`'s impls, for `or1`)
   b. Emitted by the `@inner` macro when `$count == 1` and `$index == 0`
3. Run `cargo test --all-features`.
4. Add a test:
   ```rust
   #[test]
   fn or1_from_and_into() {
       let or1: orn::Or1<u8> = orn::Or1::from(42u8);
       assert_eq!(or1, orn::Or1::T0(42u8));
       let back: u8 = or1.into();
       assert_eq!(back, 42u8);
   }
   ```
