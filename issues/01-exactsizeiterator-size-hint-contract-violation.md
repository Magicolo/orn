# Issue 1: `ExactSizeIterator` Contract Violation — `size_hint()` Not Implemented

## Summary

The `iter::Iterator<T...>` type generated by the `or!` macro implements `ExactSizeIterator`
with a custom `len()` override, but does **not** override `size_hint()` in the base
`core::iter::Iterator` impl. This violates the documented contract of `ExactSizeIterator`
and causes incorrect behaviour for any code that calls `size_hint()` on such an iterator.

## Location

**File:** `src/lib.rs`

Relevant generated code (inside the `or!(@main ...)` macro arm, inside the `#[cfg(feature = "iter")] pub mod iter` block):

```rust
impl<$($t: core::iter::Iterator),*> core::iter::Iterator for Iterator<$($t,)*> {
    type Item = Or<$($t::Item,)*>;

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        match self {
            $(Self::$t(item) => Some(Or::$t(item.next()?)),)*
        }
    }
    // ← NO `size_hint()` override here
}

impl<$($t: ExactSizeIterator),*> ExactSizeIterator for Iterator<$($t,)*> {
    #[inline]
    fn len(&self) -> usize {
        match self {
            $(Self::$t(item) => item.len(),)*
        }
    }
}
```

## Why It Is a Problem

### The `ExactSizeIterator` contract

The Rust standard library documentation for `ExactSizeIterator` states (emphasis added):

> This trait is a safe promise that the implementation of `Iterator::size_hint` is exact.
> More formally, prior to any calls to `next` (or `try_fold`), and with `n` defined by
> `self.len()`, **a call to `size_hint` must return `(n, Some(n))`**.

The default implementation of `Iterator::size_hint()` (used when not overridden) returns
`(0, None)`. Because the `or!` macro does **not** override `size_hint()` in the base
`Iterator` impl, `size_hint()` returns `(0, None)` even when all wrapped inner iterators
are `ExactSizeIterator`s. This directly contradicts the above contract.

### Concrete impact

Many standard-library and third-party consumers of iterators rely on `size_hint()` rather
than `len()`:

- `Vec::extend` and `collect::<Vec<_>>()` use `size_hint()` to pre-allocate capacity.
- `Iterator::zip`, `Iterator::unzip`, and similar combinators use `size_hint()` for
  optimization.
- `Iterator::enumerate` does not use `size_hint()` directly, but downstream adapters do.

When wrapping an exact-size inner iterator (e.g. `std::vec::IntoIter`, a slice iterator,
or a range), the resulting `Or` iterator will appear to have size `0` to all these callers,
leading to missed pre-allocations and degraded performance. For consumers that *assert* on
`size_hint()` consistency in debug builds, this could also cause a panic.

### Demonstrating the bug

```rust
use orn::Or2;

let v = vec![1u8, 2, 3];
let iter = Or2::<Vec<u8>, Vec<u8>>::T0(v).into_iter();

// Correct length, because len() is overridden:
assert_eq!(iter.len(), 3);           // passes

// But size_hint() is broken:
assert_eq!(iter.size_hint(), (3, Some(3)));  // FAILS: returns (0, None)
```

## Proposed Fix

Override `size_hint()` in the base `core::iter::Iterator` implementation inside the
generated `iter` module so that it delegates to the active inner iterator:

```rust
impl<$($t: core::iter::Iterator),*> core::iter::Iterator for Iterator<$($t,)*> {
    type Item = Or<$($t::Item,)*>;

    #[inline]
    fn next(&mut self) -> Option<Self::Item> {
        match self {
            $(Self::$t(item) => Some(Or::$t(item.next()?)),)*
        }
    }

    #[inline]
    fn size_hint(&self) -> (usize, Option<usize>) {
        match self {
            $(Self::$t(item) => item.size_hint(),)*
        }
    }
}
```

This single addition restores correctness: `size_hint()` now forwards to each inner
iterator's own `size_hint()`, which is exact whenever the inner iterator is
`ExactSizeIterator`.

### Additional consistency note

Once `size_hint()` is correctly implemented, the overridden `len()` in
`ExactSizeIterator` becomes redundant (the default `len()` would now derive from the
correct `size_hint()`), but keeping the explicit override is harmless and potentially
slightly faster (one branch instead of two).

## Investigation Steps for the Implementing Agent

1. Locate the `or!(@main ...)` macro arm in `src/lib.rs` (around line 120).
2. Find the `#[cfg(feature = "iter")] pub mod iter` block inside `@main`.
3. Add the `size_hint` override shown above to the `core::iter::Iterator` impl.
4. Run `cargo test --all-features` to confirm all existing tests still pass.
5. Add a targeted test in `tests/iter.rs`:

```rust
#[test]
fn size_hint_exact_size() {
    use orn::Or2;
    let v = vec![1u8, 2u8, 3u8];
    let iter = Or2::<Vec<u8>, Vec<u8>>::T0(v).into_iter();
    assert_eq!(iter.size_hint(), (3, Some(3)));
}
```

6. Verify that `collect::<Vec<_>>()` no longer reallocates by checking capacity:

```rust
let v: Vec<u8> = Or2::<Vec<u8>, Vec<u8>>::T0(vec![1, 2, 3]).into_iter()
    .map(|x| x.into_inner())
    .collect();
assert_eq!(v.len(), 3);
```
